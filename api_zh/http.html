<!doctype html>
<html lang="zh">

<head>
    <meta charset="utf-8">
    <title>HTTP Node.js v6.2.0 Manual &amp; Documentation</title>
    <link rel="stylesheet" href="assets/css?family=Lato:400,700,400italic">
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/sh.css">
    <link rel="canonical" href="https://nodejs.org/api/http.html">
</head>

<body class="alt apidoc" id="api-section-http">
    <div id="content" class="clearfix">
        <div id="column2" class="interior">
            <div id="intro" class="interior">
                <a href="/" title="Go back to the home page"> Node.js </a>
            </div>
            <ul>
                <li><a class="nav-documentation" href="documentation.html">About these Docs</a></li>
                <li><a class="nav-synopsis" href="synopsis.html">Usage &amp; Example</a></li>
            </ul>
            <div class="line"></div>

            <ul>
                <li><a class="nav-assert" href="assert.html">Assertion Testing</a></li>
                <li><a class="nav-buffer" href="buffer.html">Buffer</a></li>
                <li><a class="nav-addons" href="addons.html">C/C++ Addons</a></li>
                <li><a class="nav-child_process" href="child_process.html">Child Processes</a></li>
                <li><a class="nav-cluster" href="cluster.html">Cluster</a></li>
                <li><a class="nav-cli" href="cli.html">Command Line Options</a></li>
                <li><a class="nav-console" href="console.html">Console</a></li>
                <li><a class="nav-crypto" href="crypto.html">Crypto</a></li>
                <li><a class="nav-debugger" href="debugger.html">Debugger</a></li>
                <li><a class="nav-dns" href="dns.html">DNS</a></li>
                <li><a class="nav-domain" href="domain.html">Domain</a></li>
                <li><a class="nav-errors" href="errors.html">Errors</a></li>
                <li><a class="nav-events" href="events.html">Events</a></li>
                <li><a class="nav-fs" href="fs.html">File System</a></li>
                <li><a class="nav-globals" href="globals.html">Globals</a></li>
                <li><a class="nav-http active" href="http.html">HTTP</a></li>
                <li><a class="nav-https" href="https.html">HTTPS</a></li>
                <li><a class="nav-modules" href="modules.html">Modules</a></li>
                <li><a class="nav-net" href="net.html">Net</a></li>
                <li><a class="nav-os" href="os.html">OS</a></li>
                <li><a class="nav-path" href="path.html">Path</a></li>
                <li><a class="nav-process" href="process.html">Process</a></li>
                <li><a class="nav-punycode" href="punycode.html">Punycode</a></li>
                <li><a class="nav-querystring" href="querystring.html">Query Strings</a></li>
                <li><a class="nav-readline" href="readline.html">Readline</a></li>
                <li><a class="nav-repl" href="repl.html">REPL</a></li>
                <li><a class="nav-stream" href="stream.html">Stream</a></li>
                <li><a class="nav-string_decoder" href="string_decoder.html">String Decoder</a></li>
                <li><a class="nav-timers" href="timers.html">Timers</a></li>
                <li><a class="nav-tls" href="tls.html">TLS/SSL</a></li>
                <li><a class="nav-tty" href="tty.html">TTY</a></li>
                <li><a class="nav-dgram" href="dgram.html">UDP/Datagram</a></li>
                <li><a class="nav-url" href="url.html">URL</a></li>
                <li><a class="nav-util" href="util.html">Utilities</a></li>
                <li><a class="nav-v8" href="v8.html">V8</a></li>
                <li><a class="nav-vm" href="vm.html">VM</a></li>
                <li><a class="nav-zlib" href="zlib.html">ZLIB</a></li>
            </ul>
            <div class="line"></div>

            <ul>
                <li><a class="nav-https-github-com-nodejs-node" href="https://github.com/nodejs/node">GitHub Repo &amp; Issue Tracker</a></li>
                <li><a class="nav-http-groups-google-com-group-nodejs" href="http://groups.google.com/group/nodejs">Mailing List</a></li>
            </ul>

        </div>

        <div id="column1" data-id="http" class="interior">
            <header>
                <h1>Node.js v6.2.0 Documentation</h1>
                <div id="gtoc">
                    <p>
                        <a href="index.html" name="toc">Index</a> |
                        <a href="all.html">View on single page</a> |
                        <a href="http.json">View as JSON</a>
                    </p>
                </div>
                <hr>
            </header>

            <div id="toc">
                <h2>Table of Contents</h2>
                <ul>
                    <li><a href="#http_http">HTTP</a>
                        <ul>
                            <li><a href="#http_class_http_agent">Class: http.Agent</a>
                                <ul>
                                    <li><a href="#http_new_agent_options">new Agent([options])</a></li>
                                    <li><a href="#http_agent_createconnection_options_callback">agent.createConnection(options[, callback])</a></li>
                                    <li><a href="#http_agent_destroy">agent.destroy()</a></li>
                                    <li><a href="#http_agent_freesockets">agent.freeSockets</a></li>
                                    <li><a href="#http_agent_getname_options">agent.getName(options)</a></li>
                                    <li><a href="#http_agent_maxfreesockets">agent.maxFreeSockets</a></li>
                                    <li><a href="#http_agent_maxsockets">agent.maxSockets</a></li>
                                    <li><a href="#http_agent_requests">agent.requests</a></li>
                                    <li><a href="#http_agent_sockets">agent.sockets</a></li>
                                </ul>
                            </li>
                            <li><a href="#http_class_http_clientrequest">Class: http.ClientRequest</a>
                                <ul>
                                    <li><a href="#http_event_abort">Event: &#39;abort&#39;</a></li>
                                    <li><a href="#http_event_checkexpectation">Event: &#39;checkExpectation&#39;</a></li>
                                    <li><a href="#http_event_connect">Event: &#39;connect&#39;</a></li>
                                    <li><a href="#http_event_continue">Event: &#39;continue&#39;</a></li>
                                    <li><a href="#http_event_response">Event: &#39;response&#39;</a></li>
                                    <li><a href="#http_event_socket">Event: &#39;socket&#39;</a></li>
                                    <li><a href="#http_event_upgrade">Event: &#39;upgrade&#39;</a></li>
                                    <li><a href="#http_request_abort">request.abort()</a></li>
                                    <li><a href="#http_request_end_data_encoding_callback">request.end([data][, encoding][, callback])</a></li>
                                    <li><a href="#http_request_flushheaders">request.flushHeaders()</a></li>
                                    <li><a href="#http_request_setnodelay_nodelay">request.setNoDelay([noDelay])</a></li>
                                    <li><a href="#http_request_setsocketkeepalive_enable_initialdelay">request.setSocketKeepAlive([enable][, initialDelay])</a></li>
                                    <li><a href="#http_request_settimeout_timeout_callback">request.setTimeout(timeout[, callback])</a></li>
                                    <li><a href="#http_request_write_chunk_encoding_callback">request.write(chunk[, encoding][, callback])</a></li>
                                </ul>
                            </li>
                            <li><a href="#http_class_http_server">Class: http.Server</a>
                                <ul>
                                    <li><a href="#http_event_checkcontinue">Event: &#39;checkContinue&#39;</a></li>
                                    <li><a href="#http_event_clienterror">Event: &#39;clientError&#39;</a></li>
                                    <li><a href="#http_event_close">Event: &#39;close&#39;</a></li>
                                    <li><a href="#http_event_connect_1">Event: &#39;connect&#39;</a></li>
                                    <li><a href="#http_event_connection">Event: &#39;connection&#39;</a></li>
                                    <li><a href="#http_event_request">Event: &#39;request&#39;</a></li>
                                    <li><a href="#http_event_upgrade_1">Event: &#39;upgrade&#39;</a></li>
                                    <li><a href="#http_server_close_callback">server.close([callback])</a></li>
                                    <li><a href="#http_server_listen_handle_callback">server.listen(handle[, callback])</a></li>
                                    <li><a href="#http_server_listen_path_callback">server.listen(path[, callback])</a></li>
                                    <li><a href="#http_server_listen_port_hostname_backlog_callback">server.listen(port[, hostname][, backlog][, callback])</a></li>
                                    <li><a href="#http_server_listening">server.listening</a></li>
                                    <li><a href="#http_server_maxheaderscount">server.maxHeadersCount</a></li>
                                    <li><a href="#http_server_settimeout_msecs_callback">server.setTimeout(msecs, callback)</a></li>
                                    <li><a href="#http_server_timeout">server.timeout</a></li>
                                </ul>
                            </li>
                            <li><a href="#http_class_http_serverresponse">Class: http.ServerResponse</a>
                                <ul>
                                    <li><a href="#http_event_close_1">Event: &#39;close&#39;</a></li>
                                    <li><a href="#http_event_finish">Event: &#39;finish&#39;</a></li>
                                    <li><a href="#http_response_addtrailers_headers">response.addTrailers(headers)</a></li>
                                    <li><a href="#http_response_end_data_encoding_callback">response.end([data][, encoding][, callback])</a></li>
                                    <li><a href="#http_response_finished">response.finished</a></li>
                                    <li><a href="#http_response_getheader_name">response.getHeader(name)</a></li>
                                    <li><a href="#http_response_headerssent">response.headersSent</a></li>
                                    <li><a href="#http_response_removeheader_name">response.removeHeader(name)</a></li>
                                    <li><a href="#http_response_senddate">response.sendDate</a></li>
                                    <li><a href="#http_response_setheader_name_value">response.setHeader(name, value)</a></li>
                                    <li><a href="#http_response_settimeout_msecs_callback">response.setTimeout(msecs, callback)</a></li>
                                    <li><a href="#http_response_statuscode">response.statusCode</a></li>
                                    <li><a href="#http_response_statusmessage">response.statusMessage</a></li>
                                    <li><a href="#http_response_write_chunk_encoding_callback">response.write(chunk[, encoding][, callback])</a></li>
                                    <li><a href="#http_response_writecontinue">response.writeContinue()</a></li>
                                    <li><a href="#http_response_writehead_statuscode_statusmessage_headers">response.writeHead(statusCode[, statusMessage][, headers])</a></li>
                                </ul>
                            </li>
                            <li><a href="#http_class_http_incomingmessage">Class: http.IncomingMessage</a>
                                <ul>
                                    <li><a href="#http_event_close_2">Event: &#39;close&#39;</a></li>
                                    <li><a href="#http_message_headers">message.headers</a></li>
                                    <li><a href="#http_message_httpversion">message.httpVersion</a></li>
                                    <li><a href="#http_message_method">message.method</a></li>
                                    <li><a href="#http_message_rawheaders">message.rawHeaders</a></li>
                                    <li><a href="#http_message_rawtrailers">message.rawTrailers</a></li>
                                    <li><a href="#http_message_settimeout_msecs_callback">message.setTimeout(msecs, callback)</a></li>
                                    <li><a href="#http_message_statuscode">message.statusCode</a></li>
                                    <li><a href="#http_message_statusmessage">message.statusMessage</a></li>
                                    <li><a href="#http_message_socket">message.socket</a></li>
                                    <li><a href="#http_message_trailers">message.trailers</a></li>
                                    <li><a href="#http_message_url">message.url</a></li>
                                </ul>
                            </li>
                            <li><a href="#http_http_methods">http.METHODS</a></li>
                            <li><a href="#http_http_status_codes">http.STATUS_CODES</a></li>
                            <li><a href="#http_http_createclient_port_host">http.createClient([port][, host])</a></li>
                            <li><a href="#http_http_createserver_requestlistener">http.createServer([requestListener])</a></li>
                            <li><a href="#http_http_get_options_callback">http.get(options[, callback])</a></li>
                            <li><a href="#http_http_globalagent">http.globalAgent</a></li>
                            <li><a href="#http_http_request_options_callback">http.request(options[, callback])</a></li>
                        </ul>
                    </li>
                </ul>

            </div>

            <div id="apicontent">
                <h1>HTTP<span><a class="mark" href="#http_http" id="http_http">#</a></span></h1>
                <pre class="api_stability api_stability_2">稳定性: 2 - 稳定</pre>
                <p>要使用 HTTP 服务器或客户端功能，需引用此模块 <code>require(&#39;http&#39;)</code>。</p>
                <p>Node.js 中的 HTTP 接口被用来支持 HTTP 协议中许多在传统上一直难以使用的特性，特别是一些很大、可能已被块编码了的消息。
                    这些接口会谨慎地处理请求(request) 或响应(response)--用户可用来处理数据流，从来不把她们整个地流缓存下来。</p>
                <p>HTTP 的消息头(Headers)通过如下对象来表示：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>To use the HTTP server and client one must <code>require(&#39;http&#39;)</code>.</p>
                        <p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages. The interface is careful to never buffer entire
                            requests or responses--the user is able to stream data.</p>
                        <p>HTTP message headers are represented by an object like this:</p>
                    </div>
                </div>
                <pre><code>{ &#39;content-length&#39;: &#39;123&#39;,
  &#39;content-type&#39;: &#39;text/plain&#39;,
  &#39;connection&#39;: &#39;keep-alive&#39;,
  &#39;host&#39;: &#39;mysite.com&#39;,
  &#39;accept&#39;: &#39;*/*&#39; }
</code></pre>
                <p>键为小写字母，值是不可修改。</p>
                <p>为了全面支持各种可能的 HTTP 应用，Node.js 提供的 HTTP API 都很底层。它处理的只有流处理和消息解析。它把一份消息解析成报文头和报文体，
                    但是它不解析实际的报文头和报文体。</p>
                <p>参考 <a href="#http_message_headers"><code>message.headers</code></a> 了解如何复制和处理文头。</p>
                <p>接收到的原始报文头信息以数组形式 <code>[key, value, key2, value2, ...]</code> 保存在 <code>rawHeaders</code> 属性中. 例如,
                    前面提到的消息对象可能会有 <code>rawHeaders</code> 列表如下：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Keys are lowercased. Values are not modified.</p>
                        <p>In order to support the full spectrum of possible HTTP applications, Node.js&#39;s HTTP API is very low-level. It deals with stream handling and message parsing only. It parses a message into headers and body but it does not parse the
                            actual headers or the body.</p>
                        <p>See <a href="#http_message_headers"><code>message.headers</code></a> for details on how duplicate headers are handled.</p>
                        <p>The raw headers as they were received are retained in the <code>rawHeaders</code> property, which is an array of <code>[key, value, key2, value2, ...]</code>. For example, the previous message header object might have a <code>rawHeaders</code>                    list like the following:</p>
                    </div>
                </div>
                <pre><code>[ &#39;ConTent-Length&#39;, &#39;123456&#39;,
  &#39;content-LENGTH&#39;, &#39;123&#39;,
  &#39;content-type&#39;, &#39;text/plain&#39;,
  &#39;CONNECTION&#39;, &#39;keep-alive&#39;,
  &#39;Host&#39;, &#39;mysite.com&#39;,
  &#39;accepT&#39;, &#39;*/*&#39; ]
</code></pre>
                <h2>Class: http.Agent<span><a class="mark" href="#http_class_http_agent" id="http_class_http_agent">#</a></span></h2>
                <p>HTTP Agent 是用于把套接字做成资源池，用于 HTTP 客户端请求。</p>
                <p>HTTP Agent 也把客户端的请求默认为使用 Connection:keep-alive。如果没有HTTP请求正在等待成为空闲的套接字的话，
                    那么套接字将关闭。这意味着 keep-alive 给 Node.js 的资源池在负载带来好处是：当处于未满负荷状态时，
                    仍然不需要开发人员使用 KeepAlive 来手动关闭 HTTP 客户端。</p>
                <p>如果你选择使用 HTTP KeepAlive，那么你可以创建一个标志设为 <code>true</code> 的 Agent 对象。(见 <a href="#http_new_agent_options">构造函数参数</a>.)
                    然后，Agent 将会在资源池中保持未被使用的套接字，用于后续使用。它们将会被显式标记，以致 Node.js 进程不会一直保持运行状态。
                    但是，当 KeepAlive agent 没有被使用时，显式地 <a href="#http_agent_destroy"><code>destroy()</code></a> KeepAlive agent 仍然是个好主意，
                    这样套接字们会被关闭。</p>
                <p>当套接字触发了 <code>&#39;close&#39;</code> 事件或者专用的 <code>&#39;agentRemove&#39;</code> 事件时，套接字们会从 agent 的资源池中被移除。
                    这意味着如果你打算保持一个 HTTP 请求长时间开启，并且不希望它保持在资源池中，你可以按下列代码来：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The HTTP Agent is used for pooling sockets used in HTTP client requests.
                        </p>
                        <p>The HTTP Agent also defaults client requests to using Connection:keep-alive. If no pending HTTP requests are waiting on a socket to become free the socket is closed. This means that Node.js&#39;s pool has the benefit of keep-alive when
                            under load but still does not require developers to manually close the HTTP clients using KeepAlive.
                        </p>
                        <p>If you opt into using HTTP KeepAlive, you can create an Agent object with that flag set to <code>true</code>. (See the <a href="#http_new_agent_options">constructor options</a>.) Then, the Agent will keep unused sockets in a pool for later
                            use. They will be explicitly marked so as to not keep the Node.js process running. However, it is still a good idea to explicitly <a href="#http_agent_destroy"><code>destroy()</code></a> KeepAlive agents when they are no longer in
                            use, so that the Sockets will be shut down.
                        </p>
                        <p>Sockets are removed from the agent&#39;s pool when the socket emits either a <code>&#39;close&#39;</code> event or a special <code>&#39;agentRemove&#39;</code> event. This means that if you intend to keep one HTTP request open for a long
                            time and don&#39;t want it to stay in the pool you can do something along the lines of:</p>
                    </div>
                </div>
                <pre><code class="lang-js">http.get(options, (res) =&gt; {
  // Do stuff
}).on(&#39;socket&#39;, (socket) =&gt; {
  socket.emit(&#39;agentRemove&#39;);
});
</code></pre>
                <p>另一个选择，你可以直接使用 <code>agent:false</code> 选择完全停用资源池。
                    (Alternatively, you could just opt out of pooling entirely using
                    <code>agent:false</code>)：</p>
                <pre><code class="lang-js">http.get({
  hostname: &#39;localhost&#39;,
  port: 80,
  path: &#39;/&#39;,
  agent: false  // create a new agent just for this one request
}, (res) =&gt; {
  // Do stuff with response
})
</code></pre>
                <h3>new Agent([options])<span><a class="mark" href="#http_new_agent_options" id="http_new_agent_options">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a>
                            设置于 agent 上的那些可配置选项的集合。可以有下列字段：
                            <ul>
                                <li><code>keepAlive</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a>
                                    在资源池中维持套接字，后续可被其它请求使用。默认 = <code>false</code></li>
                                <li><code>keepAliveMsecs</code> <span class="type">&lt;Integer&gt;</span>
                                    当使用 HTTP KeepAlive 时，通过保持活跃的套接字发送 TCP KeepAlive 数据包的频率(以毫秒计算)。默认 = <code>1000</code>。
                                    只针对于如果 <code>keepAlive</code> 设置为 <code>true</code> 的情况</li>
                                <li><code>maxSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a>
                                    每台主机允许的套接字的数目的最大值。默认 = <code>无穷(Infinity)</code>。</li>
                                <li><code>maxFreeSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a>
                                    在空闲状态下还依然开启的套接字的最大值。仅当 <code>keepAlive</code> 设置为 <code>true</code> 时有效。默认 = <code>256</code>。</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <p>被 <a href="#http_http_request_options_callback"><code>http.request()</code></a> 使用的默认
                    的 <a href="#http_http_globalagent"><code>http.globalAgent</code></a>，她所有的这些设置都被设置为对于的默认值。</p>
                <p>要配置这些值，你必须创建你自己的 <a href="#http_class_http_agent"><code>http.Agent</code></a> 对象。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <div class="signature">
                            <ul>
                                <li><code>options</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a> Set of configurable options to set on the agent. Can have the following fields:
                                    <ul>
                                        <li><code>keepAlive</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Boolean_type" class="type">&lt;Boolean&gt;</a> Keep sockets around in a pool to be used by other requests in the future.
                                            Default = <code>false</code></li>
                                        <li><code>keepAliveMsecs</code> <span class="type">&lt;Integer&gt;</span> When using HTTP KeepAlive, how often to send TCP KeepAlive packets over sockets being kept alive. Default = <code>1000</code>. Only relevant if <code>keepAlive</code>                                    is set to <code>true</code>.</li>
                                        <li><code>maxSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Maximum number of sockets to allow per host. Default = <code>Infinity</code>.</li>
                                        <li><code>maxFreeSockets</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Maximum number of sockets to leave open in a free state. Only relevant
                                            if <code>keepAlive</code> is set to <code>true</code>. Default = <code>256</code>.</li>
                                    </ul>
                                </li>
                            </ul>
                        </div>
                        <p>The default <a href="#http_http_globalagent"><code>http.globalAgent</code></a> that is used by <a href="#http_http_request_options_callback"><code>http.request()</code></a> has all of these values set to their respective defaults.</p>
                        <p>To configure any of them, you must create your own <a href="#http_class_http_agent"><code>http.Agent</code></a> object.</p>
                    </div>
                </div>
                <pre><code class="lang-js">const http = require(&#39;http&#39;);
var keepAliveAgent = new http.Agent({ keepAlive: true });
options.agent = keepAliveAgent;
http.request(options, onResponseCallback);
</code></pre>
                <h3>agent.createConnection(options[, callback])<span><a class="mark" href="#http_agent_createconnection_options_callback" id="http_agent_createconnection_options_callback">#</a></span></h3>
                <p>为 HTTP 请求产生一个套接字/流。</p>
                <p>默认，这个方法和 <a href="net.html#net_net_createconnection_options_connectlistener"><code>net.createConnection()</code></a> 一样。
                    但在这个方法里面使用自定义的重载的 Agent 的情况下非常的灵活。</p>
                <p>一个套接字/流可以以两种方式提供：从这个方法里面返回一个套接字/流，或传递一个套接字/流给回调。</p>
                <p><code>callback</code> 函数签名带两个参数 <code>(err, stream)</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Produces a socket/stream to be used for HTTP requests.</p>
                        <p>By default, this function is the same as <a href="net.html#net_net_createconnection_options_connectlistener"><code>net.createConnection()</code></a>. However, custom Agents may override this method in case greater flexibility is desired.</p>
                        <p>A socket/stream can be supplied in one of two ways: by returning the socket/stream from this function, or by passing the socket/stream to <code>callback</code>.</p>
                        <p><code>callback</code> has a signature of <code>(err, stream)</code>.</p>
                    </div>
                </div>
                <h3>agent.destroy()<span><a class="mark" href="#http_agent_destroy" id="http_agent_destroy">#</a></span></h3>
                <p>销毁当前被此 agent 占用的任何套接字。</p>
                <p>通常并不需要这样做。但是，如果 agent 开启了 KeepAlive，那么当我们知道一个保持连接的代理不会再被用到时，最好还是把它关掉。
                    否则，套接字在被服务器结束之前可能会保持相当长的一段时间的打开状态。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Destroy any sockets that are currently in use by the agent.</p>
                        <p>It is usually not necessary to do this. However, if you are using an agent with KeepAlive enabled, then it is best to explicitly shut down the agent when you know that it will no longer be used. Otherwise, sockets may hang open for quite
                            a long time before the server terminates them.</p>
                    </div>
                </div>
                <h3>agent.freeSockets<span><a class="mark" href="#http_agent_freesockets" id="http_agent_freesockets">#</a></span></h3>
                <p>一个数组，在 HTTP KeepAlive 开启时，数组里面包含了那些等待被 Agent 使用的套接字。请不要修改。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>An object which contains arrays of sockets currently awaiting use by the Agent when HTTP KeepAlive is used. Do not modify.</p>
                    </div>
                </div>
                <h3>agent.getName(options)<span><a class="mark" href="#http_agent_getname_options" id="http_agent_getname_options">#</a></span></h3>
                <p>为一组请求选项(options)集合获得一个独一无二的名称，来决定是否一个连接是否可复用。 在 http 代理中，它将返回 <code>host:port:localAddress</code>。
                    在 https 代理中，这个名称包含CA、cert、ciphers和其他 HTTPS/TLS 特殊选项来决定一个套接字的可复用性。</p>
                <p>选项：</p>
                <ul>
                    <li><code>host</code>: 发出请求的目标服务器的域名或 IP 地址。</li>
                    <li><code>port</code>: 远程服务器的端口。</li>
                    <li><code>localAddress</code>: 当发出请求时，绑定给网络连接的本地接口。</li>
                </ul>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Get a unique name for a set of request options, to determine whether a connection can be reused. In the http agent, this returns
                            <code>host:port:localAddress</code>. In the https agent, the name includes the CA, cert, ciphers, and other HTTPS/TLS-specific options that determine socket reusability.</p>
                        <p>Options:</p>
                        <ul>
                            <li><code>host</code>: A domain name or IP address of the server to issue the request to.</li>
                            <li><code>port</code>: Port of remote server.</li>
                            <li><code>localAddress</code>: Local interface to bind for network connections when issuing the request.</li>
                        </ul>
                    </div>
                </div>
                <h3>agent.maxFreeSockets<span><a class="mark" href="#http_agent_maxfreesockets" id="http_agent_maxfreesockets">#</a></span></h3>
                <p>默认为 256，因为 Agents 支持 HTTP KeepAlive，所以这个参数设置的是套接字在空闲状态下保持打开状态的最大数目。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>By default set to 256. For Agents supporting HTTP KeepAlive, this sets the maximum number of sockets that will be left open in the free state.</p>
                    </div>
                </div>
                <h3>agent.maxSockets<span><a class="mark" href="#http_agent_maxsockets" id="http_agent_maxsockets">#</a></span></h3>
                <p>默认为无穷(Infinity)。决定每打开一个源，代理 agnet 可以占有的并发套接字的数量。源是一个 &#39;host:port&#39; 或 &#39;host:port:localAddress&#39; 组合。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>By default set to Infinity. Determines how many concurrent sockets the agent can have open per origin. Origin is either a &#39;host:port&#39; or &#39;host:port:localAddress&#39; combination.</p>
                    </div>
                </div>
                <h3>agent.requests<span><a class="mark" href="#http_agent_requests" id="http_agent_requests">#</a></span></h3>
                <p>一个保存还没有指定套接字的请求队列对象。请不要修改。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>An object which contains queues of requests that have not yet been assigned to sockets. Do not modify.</p>
                    </div>
                </div>
                <h3>agent.sockets<span><a class="mark" href="#http_agent_sockets" id="http_agent_sockets">#</a></span></h3>
                <p>一个保存当前被代理使用的套接字的数组对象。请不要修改。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>An object which contains arrays of sockets currently in use by the Agent. Do not modify.</p>
                    </div>
                </div>
                <h2>Class: http.ClientRequest<span><a class="mark" href="#http_class_http_clientrequest" id="http_class_http_clientrequest">#</a></span></h2>
                <p>该对象在内部创建，并由 <a href="#http_http_request_options_callback"><code>http.request()</code></a> 返回。它表示着一个<em>正在处理</em>的请求，
                    其头部已经进入请求队列。该头部仍然可以通过 <code>setHeader(name, value)</code>、<code>getHeader(name)</code>、<code>removeHeader(name)</code>
                    等 API 进行修改。实际的头部将会随着第一个数据块发送或在连接关闭时发送。</p>
                <p>为了获得响应对象，得给请求对象添加一个 <code>&#39;response&#39;</code> 监听器。当接收到响应头时，请求对象将会触发 <code>&#39;response&#39;</code>。
                    <code>&#39;response&#39;</code> 事件执行时带一个参数，该参数为 <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a>
                    的一个实例。</p>
                <p>在 <code>&#39;response&#39;</code> 事件期间，可以为响应对象添加监听器，尤其是监听 <code>&#39;data&#39;</code> 事件。</p>
                <p>如果没有添加 <code>&#39;response&#39;</code> 处理函数，响应将被完全丢弃。然而，如果你添加了一个 <code>&#39;response&#39;</code> 事件处理函数，
                    那么你<strong>必须</strong>消费掉响应对象过来的数据：
                    可以在有 <code>&#39;readable&#39;</code> 事件时调用 <code>response.read()</code>，或添加一个<code>&#39;data&#39;</code>处理函数，
                    也可以调用 <code>.resume()</code> 方法。直到数据被消费掉后，<code>&#39;end&#39;</code> 事件被触发。
                    如果数据未被读取，它将会消耗内存，最终产生 'process out of memory' 错误。</p>
                <p>注意：Node.js 不会检查 Content-Length 和被传输的报文体长度是否相同。</p>
                <p>该请求实现了 <a href="stream.html#stream_class_stream_writable">Writable Stream</a> 接口。这是一个包含下列事件
                    的 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a>：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>This object is created internally and returned from <a href="#http_http_request_options_callback"><code>http.request()</code></a>. It represents an <em>in-progress</em> request whose header has already been queued. The header is still
                            mutable using the <code>setHeader(name, value)</code>, <code>getHeader(name)</code>,
                            <code>removeHeader(name)</code> API. The actual header will be sent along with the first data chunk or when closing the connection.</p>
                        <p>To get the response, add a listener for <code>&#39;response&#39;</code> to the request object.
                            <code>&#39;response&#39;</code> will be emitted from the request object when the response headers have been received. The <code>&#39;response&#39;</code> event is executed with one argument which is an instance of <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a>.</p>
                        <p>During the <code>&#39;response&#39;</code> event, one can add listeners to the response object; particularly to listen for the <code>&#39;data&#39;</code> event.</p>
                        <p>If no <code>&#39;response&#39;</code> handler is added, then the response will be entirely discarded. However, if you add a <code>&#39;response&#39;</code> event handler, then you <strong>must</strong> consume the data from the response
                            object, either by calling <code>response.read()</code> whenever there is a <code>&#39;readable&#39;</code> event, or by adding a <code>&#39;data&#39;</code> handler, or by calling the <code>.resume()</code> method. Until the data is
                            consumed, the <code>&#39;end&#39;</code> event will not fire. Also, until the data is read it will consume memory that can eventually lead to a &#39;process out of memory&#39; error.</p>
                        <p>Note: Node.js does not check whether Content-Length and the length of the body which has been transmitted are equal or not.</p>
                        <p>The request implements the <a href="stream.html#stream_class_stream_writable">Writable Stream</a> interface. This is an
                            <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> with the following events:</p>
                    </div>
                </div>
                <h3>Event: &#39;abort&#39;<span><a class="mark" href="#http_event_abort" id="http_event_abort">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>当请求被客户端终止掉是触发。该事件只在首次调用 <code>abort()</code> 触发。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted when the request has been aborted by the client. This event is only emitted on the first call to <code>abort()</code>.</p>
                    </div>
                </div>
                <h3>Event: &#39;checkExpectation&#39;<span><a class="mark" href="#http_event_checkexpectation" id="http_event_checkexpectation">#</a></span></h3>
                <p><code>function (request, response) { }</code></p>
                <p>每当接受到带有 http 期望报文头(http Expect header)的请求时触发。该期望值不是 100-继续。如果这个时间没有被监听，那么服务器会酌情自动以
                    一个代号 417 请求头 Expect 中指定的预期内容无法被服务器满足(417 Expectation Failed)做回应。</p>
                <p>(译者：在这里 <a target="_blank" href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">HTTP状态码</a> 可以了解 100-Continue、417 状态码。)</p>
            <p>注意，如果这个事件被触发和处理掉了，那 <code>request</code> 事件将不会被触发。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><code>function (request, response) { }</code></p>
                        <p>Emitted each time a request with an http Expect header is received, where the value is not 100-continue. If this event isn&#39;t listened for, the server will automatically respond with a 417 Expectation Failed as appropriate.</p>
                        <p>Note that when this event is emitted and handled, the <code>request</code> event will not be emitted.</p>
                    </div>
                </div>
                <h3>Event: &#39;connect&#39;<span><a class="mark" href="#http_event_connect" id="http_event_connect">#</a></span></h3>
                <p><code>function (response, socket, head) { }</code></p>
                <p>每当服务器用 <code>CONNECT</code> 方法回应一个客户端请求时触发。如果未监听该事件，那些接受 <code>CONNECT</code> 方法的客户端会关闭她们自己的连接。</p>
                <p>下面一组客户端服务器对，展示如何监听 <code>&#39;connect&#39;</code> 事件。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><code>function (response, socket, head) { }</code></p>
                        <p>Emitted each time a server responds to a request with a <code>CONNECT</code> method. If this event isn&#39;t being listened for, clients receiving a <code>CONNECT</code> method will have their connections closed.</p>
                        <p>A client server pair that show you how to listen for the <code>&#39;connect&#39;</code> event.</p>
                    </div>
                </div>
                <pre><code class="lang-js">const http = require(&#39;http&#39;);
const net = require(&#39;net&#39;);
const url = require(&#39;url&#39;);

// Create an HTTP tunneling proxy
var proxy = http.createServer( (req, res) =&gt; {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
proxy.on(&#39;connect&#39;, (req, cltSocket, head) =&gt; {
  // connect to an origin server
  var srvUrl = url.parse(`http://${req.url}`);
  var srvSocket = net.connect(srvUrl.port, srvUrl.hostname, () =&gt; {
    cltSocket.write(&#39;HTTP/1.1 200 Connection Established\r\n&#39; +
                    &#39;Proxy-agent: Node.js-Proxy\r\n&#39; +
                    &#39;\r\n&#39;);
    srvSocket.write(head);
    srvSocket.pipe(cltSocket);
    cltSocket.pipe(srvSocket);
  });
});

// now that proxy is running
proxy.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {

  // make a request to a tunneling proxy
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    method: &#39;CONNECT&#39;,
    path: &#39;www.google.com:80&#39;
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;connect&#39;, (res, socket, head) =&gt; {
    console.log(&#39;got connected!&#39;);

    // make a request over an HTTP tunnel
    socket.write(&#39;GET / HTTP/1.1\r\n&#39; +
                 &#39;Host: www.google.com:80\r\n&#39; +
                 &#39;Connection: close\r\n&#39; +
                 &#39;\r\n&#39;);
    socket.on(&#39;data&#39;, (chunk) =&gt; {
      console.log(chunk.toString());
    });
    socket.on(&#39;end&#39;, () =&gt; {
      proxy.close();
    });
  });
});
</code></pre>
                <h3>Event: &#39;continue&#39;<span><a class="mark" href="#http_event_continue" id="http_event_continue">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>当服务器发送一个 &#39;100 Continue&#39; HTTP 回应是触发，通常，这个回应包含了 &#39;Expect: 100-continue&#39;。这是一条指令让客户端必须发生请求报文体。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted when the server sends a &#39;100 Continue&#39; HTTP response, usually because the request contained &#39;Expect: 100-continue&#39;. This is an instruction that the client should send the request body.</p>
                    </div>
                </div>
                <h3>Event: &#39;response&#39;<span><a class="mark" href="#http_event_response" id="http_event_response">#</a></span></h3>
                <p><code>function (response) { }</code></p>
                <p>当该请求接收到响应时触发，该事件只被触发一次。<code>response</code> 参数是 <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> 的一个实例。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted when a response is received to this request. This event is emitted only once. The <code>response</code> argument will be an instance of <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a>.</p>
                    </div>
                </div>
                <h3>Event: &#39;socket&#39;<span><a class="mark" href="#http_event_socket" id="http_event_socket">#</a></span></h3>
                <p><code>function (socket) { }</code></p>
                <p>在一个套接字被赋予这个请求的时候触发(Emitted after a socket is assigned to this request)。</p>
                <h3>Event: &#39;upgrade&#39;<span><a class="mark" href="#http_event_upgrade" id="http_event_upgrade">#</a></span></h3>
                <p><code>function (response, socket, head) { }</code></p>
                <p>每当服务器返回 upgrade 响应给请求时触发。如果该事件未被监听，接受 upgrade 报文头的客户端将关闭她们自己的连接。</p>
                <p>下面一组客户端服务器对，展示如何监听  <code>&#39;upgrade&#39;</code> 事件。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted each time a server responds to a request with an upgrade. If this event isn&#39;t being listened for, clients receiving an upgrade header will have their connections closed.</p>
                        <p>A client server pair that show you how to listen for the <code>&#39;upgrade&#39;</code> event.</p>
                    </div>
                </div>
                <pre><code class="lang-js">const http = require(&#39;http&#39;);

// Create an HTTP server
var srv = http.createServer( (req, res) =&gt; {
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;okay&#39;);
});
srv.on(&#39;upgrade&#39;, (req, socket, head) =&gt; {
  socket.write(&#39;HTTP/1.1 101 Web Socket Protocol Handshake\r\n&#39; +
               &#39;Upgrade: WebSocket\r\n&#39; +
               &#39;Connection: Upgrade\r\n&#39; +
               &#39;\r\n&#39;);

  socket.pipe(socket); // echo back
});

// now that server is running
srv.listen(1337, &#39;127.0.0.1&#39;, () =&gt; {

  // make a request
  var options = {
    port: 1337,
    hostname: &#39;127.0.0.1&#39;,
    headers: {
      &#39;Connection&#39;: &#39;Upgrade&#39;,
      &#39;Upgrade&#39;: &#39;websocket&#39;
    }
  };

  var req = http.request(options);
  req.end();

  req.on(&#39;upgrade&#39;, (res, socket, upgradeHead) =&gt; {
    console.log(&#39;got upgraded!&#39;);
    socket.end();
    process.exit(0);
  });
});
</code></pre>
                <h3>request.abort()<span><a class="mark" href="#http_request_abort" id="http_request_abort">#</a></span></h3>
                <p>终止一个请求。调用了这个方法将导致留在回应报文里面的数据被丢弃、套接字被销毁。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Marks the request as aborting. Calling this will cause remaining data in the response to be dropped and the socket to be destroyed.</p>
                    </div>
                </div>
                <h3>request.end([data][, encoding][, callback])<span><a class="mark" href="#http_request_end_data_encoding_callback" id="http_request_end_data_encoding_callback">#</a></span></h3>
                <p>结束发送请求。如果请求体的某些部分还未发送，该函数将会把它们刷新到流中。如果该请求是分块的，该方法将会发送终结符<code>&#39;0\r\n\r\n&#39;</code>。</p>
                <p>如果指定了 <code>data</code>，那么等价于先调用 <a href="#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a>，
                    随后调用 <code>request.end(callback)</code>。</p>
                <p>如果指定了 <code>callback</code>，函数会在请求流完成后调用。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Finishes sending the request. If any parts of the body are unsent, it will flush them to the stream. If the request is chunked, this will send the terminating <code>&#39;0\r\n\r\n&#39;</code>.</p>
                        <p>If <code>data</code> is specified, it is equivalent to calling
                            <a href="#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a> followed by <code>request.end(callback)</code>.</p>
                        <p>If <code>callback</code> is specified, it will be called when the request stream is finished.</p>
                    </div>
                </div>
                <h3>request.flushHeaders()<span><a class="mark" href="#http_request_flushheaders" id="http_request_flushheaders">#</a></span></h3>
                <p>刷入请求头。</p>
                <p>出于效率的原因，Node.js 通常缓冲了请求头知道你调用 <code>request.end()</code> 或写第一块请求数据，然后方法努力打包请求头和数据到一个单一的 TCP 封包。</p>
                <p>一般地，这个就是你要的(节省了 TCP 往返开销)，但第一个数据可能很久以后才会被发送。<code>request.flushHeaders()</code> 让你绕过这个优化去启动请求。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Flush the request headers.</p>
                        <p>For efficiency reasons, Node.js normally buffers the request headers until you call <code>request.end()</code> or write the first chunk of request data. It then tries hard to pack the request headers and data into a single TCP packet.</p>
                        <p>That&#39;s usually what you want (it saves a TCP round-trip) but not when the first data isn&#39;t sent until possibly much later. <code>request.flushHeaders()</code> lets you bypass the optimization and kickstart the request.</p>
                    </div>
                </div>
                <h3>request.setNoDelay([noDelay])<span><a class="mark" href="#http_request_setnodelay_nodelay" id="http_request_setnodelay_nodelay">#</a></span></h3>
                <p>一旦一个套接字被分配给该请求并且已连接，<a href="net.html#net_socket_setnodelay_nodelay"><code>socket.setNoDelay()</code></a> 将会被调用。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Once a socket is assigned to this request and is connected
                            <a href="net.html#net_socket_setnodelay_nodelay"><code>socket.setNoDelay()</code></a> will be called.</p>
                    </div>
                </div>
                <h3>request.setSocketKeepAlive([enable][, initialDelay])<span><a class="mark" href="#http_request_setsocketkeepalive_enable_initialdelay" id="http_request_setsocketkeepalive_enable_initialdelay">#</a></span></h3>
                <p>一旦一个套接字被分配到这个请求，而且已连接，<a href="net.html#net_socket_setkeepalive_enable_initialdelay"><code>socket.setKeepAlive()</code></a> 就会被调用。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Once a socket is assigned to this request and is connected <a href="net.html#net_socket_setkeepalive_enable_initialdelay"><code>socket.setKeepAlive()</code></a> will be called.</p>
                    </div>
                </div>
                <h3>request.setTimeout(timeout[, callback])<span><a class="mark" href="#http_request_settimeout_timeout_callback" id="http_request_settimeout_timeout_callback">#</a></span></h3>
                <p>一旦一个套接字被分配到这个请求，而且已连接， <a href="net.html#net_socket_settimeout_timeout_callback"><code>socket.setTimeout()</code></a> 就会被调用。</p>
                <ul>
                    <li><code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> 请求超时的毫秒数。</li>
                    <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> 可选方法，在超时时调用，和绑定到 <code>timeout</code> 事件一样。</li>
                </ul>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Once a socket is assigned to this request and is connected
                            <a href="net.html#net_socket_settimeout_timeout_callback"><code>socket.setTimeout()</code></a> will be called.</p>
                        <ul>
                            <li><code>timeout</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> Milliseconds before a request is considered to be timed out.</li>
                            <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a> Optional function to be called when a timeout occurs. Same as binding to the
                                <code>timeout</code> event.</li>
                        </ul>
                    </div>
                </div>
                <h3>request.write(chunk[, encoding][, callback])<span><a class="mark" href="#http_request_write_chunk_encoding_callback" id="http_request_write_chunk_encoding_callback">#</a></span></h3>
                <p>发送一块请求体。调用该方法多次，用户可以流式地发送请求体至服务器——在这种情况下，建议创建请求时使用<code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code>头。</p>
                <p><code>chunk</code> 参数必须是 <a href="buffer.html#buffer_buffer"><code>Buffer</code></a> 或者 string。</p>
                <p><code>encoding</code> 参数是可选的, 并且只能在 <code>chunk</code> 是 string 类型的时候才能设置. 默认是 <code>&#39;utf8&#39;</code>。</p>
                <p><code>callback</code> 参数可选，当块数据被刷入是调用。</p>
                <p>返回 <code>request</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sends a chunk of the body. By calling this method many times, the user can stream a request body to a server--in that case it is suggested to use the
                            <code>[&#39;Transfer-Encoding&#39;, &#39;chunked&#39;]</code> header line when creating the request.</p>
                        <p>The <code>chunk</code> argument should be a <a href="buffer.html#buffer_buffer"><code>Buffer</code></a> or a string.</p>
                        <p>The <code>encoding</code> argument is optional and only applies when <code>chunk</code> is a string. Defaults to <code>&#39;utf8&#39;</code>.</p>
                        <p>The <code>callback</code> argument is optional and will be called when this chunk of data is flushed.</p>
                        <p>Returns <code>request</code>.</p>
                    </div>
                </div>
                <h2>Class: http.Server<span><a class="mark" href="#http_class_http_server" id="http_class_http_server">#</a></span></h2>
                <p>继承于 <a href="net.html#net_class_net_server"><code>net.Server</code></a> 且有下列这些额外的事件(This class inherits from <a href="net.html#net_class_net_server"><code>net.Server</code></a> and has the following additional events)：</p>
                <h3>Event: &#39;checkContinue&#39;<span><a class="mark" href="#http_event_checkcontinue" id="http_event_checkcontinue">#</a></span></h3>
                <p><code>function (request, response) { }</code></p>
                <p>每当接收到 Expect: 100-continue 的 http 请求触发事件。如果未监听该事件，服务器会酌情自动发送 100 Continue 响应。</p>
                <p>处理该事件时，如果客户端还应该继续发送请求报文体则调用 <a href="#http_response_writecontinue"><code>response.writeContinue()</code></a>，
                    或者，如果客户端不应该继续发送请求报文体，则生成一个合适的 HTTP 响应(例如，400 Bad Request)。</p>
                <p>注意，当这个事件触发并且被处理，则 <code>&#39;request&#39;</code> 事件将不再会触发。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted each time a request with an http Expect: 100-continue is received. If this event isn&#39;t listened for, the server will automatically respond with a 100 Continue as appropriate.</p>
                        <p>Handling this event involves calling <a href="#http_response_writecontinue"><code>response.writeContinue()</code></a> if the client should continue to send the request body, or generating an appropriate HTTP response (e.g., 400 Bad Request)
                            if the client should not continue to send the request body.</p>
                        <p>Note that when this event is emitted and handled, the <code>&#39;request&#39;</code> event will not be emitted.</p>
                    </div>
                </div>
                <h3>Event: &#39;clientError&#39;<span><a class="mark" href="#http_event_clienterror" id="http_event_clienterror">#</a></span></h3>
                <p><code>function (exception, socket) { }</code></p>
                <p>如果一个客户端连接触发了一个 <code>&#39;error&#39;</code> 事件，它就会转发到这里。该事件的监听器负责关闭/销毁底层套接字。
                    例如，某人可能希望更加优雅的关闭 '400 Bad Request' http 请求，而不是唐突地切断连接。</p>
                <p>默认行为是，立即销毁恶意请求的套接字。</p>
                <p><code>socket</code> 是 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 对象，该错误事件源于此对象。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>If a client connection emits an <code>&#39;error&#39;</code> event, it will be forwarded here. Listener of this event is responsible for closing/destroying the underlying socket. For example, one may wish to more gracefully close the socket
                            with an HTTP &#39;400 Bad Request&#39; response instead of abruptly severing the connection.</p>
                        <p>Default behavior is to destroy the socket immediately on malformed request.</p>
                        <p><code>socket</code> is the <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> object that the error originated from.</p>
                    </div>
                </div>
                <pre><code class="lang-js">const http = require(&#39;http&#39;);

const server = http.createServer((req, res) =&gt; {
  res.end();
});
server.on(&#39;clientError&#39;, (err, socket) =&gt; {
  socket.end(&#39;HTTP/1.1 400 Bad Request\r\n\r\n&#39;);
});
server.listen(8000);
</code></pre>
                <p>当 <code>&#39;clientError&#39;</code> 事件发生时，还没有 <code>request</code> 或 <code>response</code> 对象，所以任何
                     HTTP 响应，包括响应头和数据，都<em>必须</em>直接写入 <code>socket</code> 对象。必须注意确保响应是一个正确格式化的 HTTP 响应消息。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>When the <code>&#39;clientError&#39;</code> event occurs, there is no <code>request</code> or <code>response</code> object, so any HTTP response sent, including response headers and payload,
                            <em>must</em> be written directly to the <code>socket</code> object. Care must be taken to ensure the response is a properly formatted HTTP response message.</p>
                    </div>
                </div>
                <h3>Event: &#39;close&#39;<span><a class="mark" href="#http_event_close" id="http_event_close">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>当服务器关闭时触发(Emitted when the server closes)。</p>
                <h3>Event: &#39;connect&#39;<span><a class="mark" href="#http_event_connect_1" id="http_event_connect_1">#</a></span></h3>
                <p><code>function (request, socket, head) { }</code></p>
                <p>每当客户端请求 http <code>CONNECT</code> 方法是触发。如果未监听该事件，则这些请求 <code>CONNECT</code> 方法的客户端将关闭各自的连接。</p>
                <ul>
                    <li><code>request</code> 代表该 http 请求，因为她就在请求事件里面。
                    </li>
                    <li><code>socket</code> 服务器和客户端之间的套接字。</li>
                    <li><code>head</code> 一个 Buffer 实例，隧道流的第一个封包，可能为空。</li>
                </ul>
                <p>该事件触发后，由于套接字上没有 <code>&#39;data&#39;</code> 事件监听器，所以为了处理发送给服务器的数据，你必须把事件监听器绑定给。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted each time a client requests a http <code>CONNECT</code> method. If this event isn&#39;t listened for, then clients requesting a <code>CONNECT</code> method will have their connections closed.</p>
                        <ul>
                            <li><code>request</code> is the arguments for the http request, as it is in the request event.
                            </li>
                            <li><code>socket</code> is the network socket between the server and client.</li>
                            <li><code>head</code> is an instance of Buffer, the first packet of the tunneling stream, this may be empty.</li>
                        </ul>
                        <p>After this event is emitted, the request&#39;s socket will not have a <code>&#39;data&#39;</code> event listener, meaning you will need to bind to it in order to handle data sent to the server on that socket.</p>
                    </div>
                </div>
                <h3>Event: &#39;connection&#39;<span><a class="mark" href="#http_event_connection" id="http_event_connection">#</a></span></h3>
                <p><code>function (socket) { }</code></p>
                <p>新的 TCP 流建立时触发。<code>socket</code> 是一个 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 对象。
                    通常用户无需处理该事件。特别注意，协议解析器绑定套接字时采用的方式使套接字不会
                    触发 <code>&#39;readable&#39;</code> 事件。 还可以通过 <code>request.connection</code>访问 <code>socket</code> 。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>When a new TCP stream is established. <code>socket</code> is an object of type
                            <a href="net.html#net_class_net_socket"><code>net.Socket</code></a>. Usually users will not want to access this event. In particular, the socket will not emit <code>&#39;readable&#39;</code> events because of how the protocol parser
                            attaches to the socket. The <code>socket</code> can also be accessed at <code>request.connection</code>.</p>
                    </div>
                </div>
                <h3>Event: &#39;request&#39;<span><a class="mark" href="#http_event_request" id="http_event_request">#</a></span></h3>
                <p><code>function (request, response) { }</code></p>
                <p>每次收到一个请求时触发。注意每个连接又可能有多个请求(在 keep-alive 的连接中)。<code>request</code> 是 <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a>
                    的一个实例。<code>response</code> 是 <a href="#http_class_http_serverresponse"><code>http.ServerResponse</code></a> 的一个实例。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted each time there is a request. Note that there may be multiple requests per connection (in the case of keep-alive connections).
                            <code>request</code> is an instance of <a href="#http_class_http_incomingmessage"><code>http.IncomingMessage</code></a> and <code>response</code> is an instance of <a href="#http_class_http_serverresponse"><code>http.ServerResponse</code></a>.</p>
                    </div>
                </div>
                <h3>Event: &#39;upgrade&#39;<span><a class="mark" href="#http_event_upgrade_1" id="http_event_upgrade_1">#</a></span></h3>
                <p><code>function (request, socket, head) { }</code></p>
                <p>每当一个客户端请求 http 升级时触发。如果这个事件没有被监听，那么这些请求升级的客户端的连接将会各自关闭。</p>
                <ul>
                    <li><code>request</code> 是该 HTTP 请求的参数，因为她就在请求事件中。</li>
                    <li><code>socket</code> 是服务端与客户端之间的网络套接字。</li>
                    <li><code>head</code> 是一个 Buffer 实例，升级后流的第一个包，该参数可能为空。</li>
                </ul>
                <p>在这个事件被触发后，请求的套接字将不会有data事件监听器，也就是说你将需要绑定一个监听器到 <code>&#39;data&#39;</code> 事件，来处理在套接字上被发送到服务器的数据。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted each time a client requests a http upgrade. If this event isn&#39;t listened for, then clients requesting an upgrade will have their connections closed.
                        </p>
                        <ul>
                            <li><code>request</code> is the arguments for the http request, as it is in the request event.
                            </li>
                            <li><code>socket</code> is the network socket between the server and client.</li>
                            <li><code>head</code> is an instance of Buffer, the first packet of the upgraded stream, this may be empty.</li>
                        </ul>
                        <p>After this event is emitted, the request&#39;s socket will not have a <code>&#39;data&#39;</code> event listener, meaning you will need to bind to it in order to handle data sent to the server on that socket.</p>
                    </div>
                </div>
                <h3>server.close([callback])<span><a class="mark" href="#http_server_close_callback" id="http_server_close_callback">#</a></span></h3>
                <p>禁止服务端接收新的连接。见 <a href="net.html#net_server_close_callback"><code>net.Server.close()</code></a>(Stops the server from accepting new connections. See <a href="net.html#net_server_close_callback"><code>net.Server.close()</code></a>)。</p>
                <h3>server.listen(handle[, callback])<span><a class="mark" href="#http_server_listen_handle_callback" id="http_server_listen_handle_callback">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><code>handle</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a></li>
                        <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
                    </ul>
                </div>
                <p><code>handle</code> 变量可以被设置为 server 或者 socket(任一底层的 <code>_handle</code>)或者一个<code>{fd: &lt;n&gt;}</code> 对象。</p>
                <p>这将使服务器用指定的句柄接受连接，但它假设文件描述符或者句柄已经被绑定在特定的端口或者域名套接字上了。</p>
                <p>Windows 不支持监听一个文件描述符。</p>
                <p>这个函数是异步的。最后一个参数 <code>callback</code> 会被作为事件监听器添加到 <code>&#39;listening&#39;</code> 事件。另见 <a href="net.html#net_server_listen_handle_backlog_callback"><code>net.Server.listen()</code></a>。</p>
                <p>返回 <code>server</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The <code>handle</code> object can be set to either a server or socket (anything with an underlying <code>_handle</code> member), or a <code>{fd: &lt;n&gt;}</code> object.</p>
                        <p>This will cause the server to accept connections on the specified handle, but it is presumed that the file descriptor or handle has already been bound to a port or domain socket.</p>
                        <p>Listening on a file descriptor is not supported on Windows.</p>
                        <p>This function is asynchronous. The last parameter <code>callback</code> will be added as a listener for the <code>&#39;listening&#39;</code> event. See also <a href="net.html#net_server_listen_handle_backlog_callback"><code>net.Server.listen()</code></a>.</p>
                        <p>Returns <code>server</code>.</p>
                    </div>
                </div>
                <h3>server.listen(path[, callback])<span><a class="mark" href="#http_server_listen_path_callback" id="http_server_listen_path_callback">#</a></span></h3>
                <p>启动一个 UNIX 套接字服务器在所给路径 <code>path</code> 上监听连接。</p>
                <p>该函数是异步的.最后一个参数 <code>callback</code> 将会加入到 <code>&#39;listening&#39;</code> 事件的监听队列中。见 <a href="net.html#net_server_listen_path_backlog_callback"><code>net.Server.listen(path)</code></a>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Start a UNIX socket server listening for connections on the given <code>path</code>.</p>
                        <p>This function is asynchronous. The last parameter <code>callback</code> will be added as a listener for the <code>&#39;listening&#39;</code> event. See also <a href="net.html#net_server_listen_path_backlog_callback"><code>net.Server.listen(path)</code></a>.</p>
                    </div>
                </div>
                <h3>server.listen(port[, hostname][, backlog][, callback])<span><a class="mark" href="#http_server_listen_port_hostname_backlog_callback" id="http_server_listen_port_hostname_backlog_callback">#</a></span></h3>
                <p>开始在指定的<code>端口</code>和<code>主机名</code>上接收连接。如果省略<code>主机名</code>，服务器会在 IPv6 可用的情况下接收指向任意 IPv6(<code>::</code>) 地址
                    的链接，否则，指向任意 IPv4(<code>0.0.0.0</code>) 地址的链接。为 0 的端口号值将会被赋值为一个随机端口。</p>
                <p>监听一个 unix 套接字，需要提供一个文件名而不是端口号和主机名。</p>
                <p>积压量 <code>backlog</code> 是连接等待队列的最大长度。实际长度由您的操作系统通过 sysctl 设置决定，比如 Linux 上的 <code>tcp_max_syn_backlog</code> 和 <code>somaxconn</code>。
                    该参数缺省值为 511（不是 512）。</p>
                <p>这个函数是异步的。最后一个参数 <code>callback</code> 会被作为事件监听器添加到 <code>&#39;listening&#39;</code> 事件。见 <a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>net.Server.listen(port)</code></a>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Begin accepting connections on the specified <code>port</code> and <code>hostname</code>. If the
                            <code>hostname</code> is omitted, the server will accept connections on any IPv6 address (
                            <code>::</code>) when IPv6 is available, or any IPv4 address (<code>0.0.0.0</code>) otherwise. A port value of zero will assign a random port.</p>
                        <p>To listen to a unix socket, supply a filename instead of port and hostname.</p>
                        <p>Backlog is the maximum length of the queue of pending connections. The actual length will be determined by your OS through sysctl settings such as
                            <code>tcp_max_syn_backlog</code> and <code>somaxconn</code> on linux. The default value of this parameter is 511 (not 512).</p>
                        <p>This function is asynchronous. The last parameter <code>callback</code> will be added as a listener for the <code>&#39;listening&#39;</code> event. See also <a href="net.html#net_server_listen_port_hostname_backlog_callback"><code>net.Server.listen(port)</code></a>.</p>
                    </div>
                </div>
                <h3>server.listening<span><a class="mark" href="#http_server_listening" id="http_server_listening">#</a></span></h3>
                <p>一个布尔值，表明服务器是否正在监听链接(A Boolean indicating whether or not the server is listening for connections)。</p>
                <h3>server.maxHeadersCount<span><a class="mark" href="#http_server_maxheaderscount" id="http_server_maxheaderscount">#</a></span></h3>
                <p>最大请求头数目限制, 默认 1000 个。如果设置为 0，则代表不做任何限制(Limits maximum incoming headers count, equal to 1000 by default. If set to 0 - no limit will be applied)。</p>
                <h3>server.setTimeout(msecs, callback)<span><a class="mark" href="#http_server_settimeout_msecs_callback" id="http_server_settimeout_msecs_callback">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
                        <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
                    </ul>
                </div>
                <p>为套接字设置超时时间，如果超时了，在 Server 对象上触发一个 <code>&#39;timeout&#39;</code> 事件，套接字会作为参数传递给这个事件的监听器。</p>
                <p>如果在 Server 对象上有一个 <code>&#39;timeout&#39;</code> 事件监听器，那么它将被调用，而超时的套接字会作为参数传递给这个监听器。</p>
                <p>默认情况下，服务器的超时时间是 2 分钟，超时后套接字会自动销毁。 但是如果为 <code>&#39;timeout&#39;</code> 事件指定了回调函数，你需要负责处理套接字超时。</p>
                <p>返回 <code>server</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sets the timeout value for sockets, and emits a <code>&#39;timeout&#39;</code> event on the Server object, passing the socket as an argument, if a timeout occurs.
                        </p>
                        <p>If there is a <code>&#39;timeout&#39;</code> event listener on the Server object, then it will be called with the timed-out socket as an argument.</p>
                        <p>By default, the Server&#39;s timeout value is 2 minutes, and sockets are destroyed automatically if they time out. However, if you assign a callback to the Server&#39;s <code>&#39;timeout&#39;</code> event, then you are responsible for
                            handling socket timeouts.</p>
                        <p>Returns <code>server</code>.</p>
                    </div>
                </div>
                <h3>server.timeout<span><a class="mark" href="#http_server_timeout" id="http_server_timeout">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a> 默认 2 分钟(Default = 120000 (2 minutes))</li>
                    </ul>
                </div>
                <p>一个套接字被判断为超时之前的闲置毫秒数。</p>
                <p>注意套接字的超时逻辑被设定在连接上，所以更改这个值只会影响<em>新创建的</em>连接，而不会影响到现有连接。</p>
                <p>设置为 0 将禁止后续建立的连接的一切自动超时行为。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The number of milliseconds of inactivity before a socket is presumed to have timed out.</p>
                        <p>Note that the socket timeout logic is set up on connection, so changing this value only affects <em>new</em> connections to the server, not any existing connections.</p>
                        <p>Set to 0 to disable any kind of automatic timeout behavior on incoming connections.
                        </p>
                    </div>
                </div>
                <h2>Class: http.ServerResponse<span><a class="mark" href="#http_class_http_serverresponse" id="http_class_http_serverresponse">#</a></span></h2>
                <p>这是一个由 HTTP 服务器内部创建的对象--不是由用户创建的。它将作为第二个参数传递给 <code>&#39;request&#39;</code> 事件。</p>
                <p>该响应实现而不是继承了<a href="stream.html#stream_class_stream_writable">Writable Stream</a> 接口。这是一个包含下列事件的 <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a>：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>This object is created internally by a HTTP server--not by the user. It is passed as the second parameter to the <code>&#39;request&#39;</code> event.</p>
                        <p>The response implements, but does not inherit from, the <a href="stream.html#stream_class_stream_writable">Writable Stream</a> interface. This is an <a href="events.html#events_class_eventemitter"><code>EventEmitter</code></a> with the
                            following events:</p>
                    </div>
                </div>
                <h3>Event: &#39;close&#39;<span><a class="mark" href="#http_event_close_1" id="http_event_close_1">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>指明底层连接在 <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> 被调用或能刷入之前就被终结了。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Indicates that the underlying connection was terminated before
                            <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> was called or able to flush.</p>
                    </div>
                </div>
                <h3>Event: &#39;finish&#39;<span><a class="mark" href="#http_event_finish" id="http_event_finish">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>响应已被发生时触发。更具体地说，事件在响应头和响应体的最后一段交给操作系统去传输到网络上时触发。这并不意味着客户端已经收到信息。</p>
                <p>该事件触发后，不会再有其他的事件从这个响应对象上触发。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Emitted when the response has been sent. More specifically, this event is emitted when the last segment of the response headers and body have been handed off to the operating system for transmission over the network. It does not imply
                            that the client has received anything yet.</p>
                        <p>After this event, no more events will be emitted on the response object.</p>
                    </div>
                </div>
                <h3>response.addTrailers(headers)<span><a class="mark" href="#http_response_addtrailers_headers" id="http_response_addtrailers_headers">#</a></span></h3>
                <p>这个方法添加 HTTP 尾随报文头(一个在消息末尾的报文头)给响应。</p>
                <p><strong>只有</strong>当响应使用了数据块编码时尾随才会被触发。如果不是(例如，请求是HTTP/1.0)，他们将会被静默丢弃。</p>
                <p>需要注意的是，如果要触发尾随消息，HTTP 要求<code>Trailer</code>报头和一组报文头列表一起被发送，例如：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>This method adds HTTP trailing headers (a header but at the end of the message) to the response.</p>
                        <p>Trailers will <strong>only</strong> be emitted if chunked encoding is used for the response; if it is not (e.g., if the request was HTTP/1.0), they will be silently discarded.</p>
                        <p>Note that HTTP requires the <code>Trailer</code> header to be sent if you intend to emit trailers, with a list of the header fields in its value. E.g.,</p>
                    </div>
                </div>
                <pre><code class="lang-js">response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39;,
                          &#39;Trailer&#39;: &#39;Content-MD5&#39; });
response.write(fileData);
response.addTrailers({&#39;Content-MD5&#39;: &#39;7895bf4b8828b55ceaf47747b4bca667&#39;});
response.end();
</code></pre>
                <p>试图设置一个包含非法字符的头字段名或值时会导致抛出 <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Attempting to set a header field name or value that contains invalid characters will result in a <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a> being thrown.</p>
                    </div>
                </div>
                <h3>response.end([data][, encoding][, callback])<span><a class="mark" href="#http_response_end_data_encoding_callback" id="http_response_end_data_encoding_callback">#</a></span></h3>
                <p>当所有的响应报头和报文被发送完成时这个方法将信号发送给服务器；服务器会认为这个消息完成了。每次响应完成之后必须调用该方法 <code>response.end()</code>。</p>
                <p>如果指定了 <code>data</code>，就相当于先调用 <a href="#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a> 之后再调用 <code>response.end(callback)</code>。</p>
                <p>如果指定了 <code>callback</code>，她将在响应流完成时被调用。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>This method signals to the server that all of the response headers and body have been sent; that server should consider this message complete. The method, <code>response.end()</code>, MUST be called on each response.</p>
                        <p>If <code>data</code> is specified, it is equivalent to calling
                            <a href="#http_response_write_chunk_encoding_callback"><code>response.write(data, encoding)</code></a> followed by <code>response.end(callback)</code>.</p>
                        <p>If <code>callback</code> is specified, it will be called when the response stream is finished.</p>
                    </div>
                </div>
                <h3>response.finished<span><a class="mark" href="#http_response_finished" id="http_response_finished">#</a></span></h3>
                <p>指示响应是否已经完成的布尔值。开始于 <code>false</code>。在 <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> 执行后，值变为 <code>true</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Boolean value that indicates whether the response has completed. Starts as <code>false</code>. After <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> executes, the value will be <code>true</code>.</p>
                    </div>
                </div>
                <h3>response.getHeader(name)<span><a class="mark" href="#http_response_getheader_name" id="http_response_getheader_name">#</a></span></h3>
                <p>读出一个在队列中但是还没有被发送至客户端的报文头。需要注意的是 <code>name</code> 参数不区分 大小写的。她只能在报文头还没被冲洗掉之前调用。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Reads out a header that&#39;s already been queued but not sent to the client. Note that the name is case insensitive. This can only be called before headers get implicitly flushed.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">var contentType = response.getHeader(&#39;content-type&#39;);
</code></pre>
                <h3>response.headersSent<span><a class="mark" href="#http_response_headerssent" id="http_response_headerssent">#</a></span></h3>
                <p>布尔型值(只读)。如果报文头被发送，则为 true，反之为 false (Boolean (read-only). True if headers were sent, false otherwise)。</p>
                <h3>response.removeHeader(name)<span><a class="mark" href="#http_response_removeheader_name" id="http_response_removeheader_name">#</a></span></h3>
                <p>删掉一个队列内等待隐式发送的报文头 (Removes a header that&#39;s queued for implicit sending)。</p>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">response.removeHeader(&#39;Content-Encoding&#39;);
</code></pre>
                <h3>response.sendDate<span><a class="mark" href="#http_response_senddate" id="http_response_senddate">#</a></span></h3>
                <p>为 true 时，Date 报文头会自动生成，如果在报文头还未存在则会自动加入到响应中去。默认值为 true。</p>
                <p>只有在测试环境才禁用它；因为 HTTP 要求响应包含 Date 头。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>When true, the Date header will be automatically generated and sent in the response if it is not already present in the headers. Defaults to true.</p>
                        <p>This should only be disabled for testing; HTTP requires the Date header in responses.</p>
                    </div>
                </div>
                <h3>response.setHeader(name, value)<span><a class="mark" href="#http_response_setheader_name_value" id="http_response_setheader_name_value">#</a></span></h3>
                <p>为隐式消息头设置一条单独的值。如果这个头已经存在于将被送出的头中，将会被覆盖。如果需要发送多个相同名称的头，可使用一个字符串数组。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sets a single header value for implicit headers. If this header already exists in the to-be-sent headers, its value will be replaced. Use an array of strings here if you need to send multiple headers with the same name.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">response.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);
</code></pre>
                <p>或</p>
                <pre><code class="lang-js">response.setHeader(&#39;Set-Cookie&#39;, [&#39;type=ninja&#39;, &#39;language=javascript&#39;]);
</code></pre>
                <p>试图设置一个包含非法字符的头字段名或值会导致抛出一个 <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a> 错误。</p>
                <p>当头被 <a href="#http_response_setheader_name_value"><code>response.setHeader()</code></a> 设置后，她们会合并到传给 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a>
                    的任何头里面去。传给 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 的头具有更高优先级。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Attempting to set a header field name or value that contains invalid characters will result in a <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a> being thrown.</p>
                        <p>When headers have been set with <a href="#http_response_setheader_name_value"><code>response.setHeader()</code></a>, they will be merged with any headers passed to <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a>,
                            with the headers passed to
                            <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> given precedence.</p>
                    </div>
                </div>
                <pre><code class="lang-js">// returns content-type = text/plain
const server = http.createServer((req,res) =&gt; {
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);
  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;ok&#39;);
});
</code></pre>
                <h3>response.setTimeout(msecs, callback)<span><a class="mark" href="#http_response_settimeout_msecs_callback" id="http_response_settimeout_msecs_callback">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
                        <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
                    </ul>
                </div>
                <p>设定套接字的超时时间为 <code>msecs</code>。如果提供了回调函数，会将其添加为响应对象的 <code>&#39;timeout&#39;</code> 事件的监听器。</p>
                <p>如果请求、响应、服务器均未添加 <code>&#39;timeout&#39;</code> 事件监听，套接字将在超时时被销毁。如果监听了请求、响应、服务器之一的 <code>&#39;timeout&#39;</code> 事件，
                    需要自行处理超时的套接字。</p>
                <p>返回 <code>response</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sets the Socket&#39;s timeout value to <code>msecs</code>. If a callback is provided, then it is added as a listener on the <code>&#39;timeout&#39;</code> event on the response object.</p>
                        <p>If no <code>&#39;timeout&#39;</code> listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If you assign a handler on the request, the response, or the server&#39;s
                            <code>&#39;timeout&#39;</code> events, then it is your responsibility to handle timed out sockets.
                        </p>
                        <p>Returns <code>response</code>.</p>
                    </div>
                </div>
                <h3>response.statusCode<span><a class="mark" href="#http_response_statuscode" id="http_response_statuscode">#</a></span></h3>
                <p>当使用隐式头时(没有显式地调用 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 来修改头)，这个属性控制着在头被刷入时一并发送回客户端的状态码。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>When using implicit headers (not calling <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> explicitly), this property controls the status code that will be sent to the client when
                            the headers get flushed.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">response.statusCode = 404;
</code></pre>
                <p>当响应头被发送回客户端，这个属性标识已经被发送出去的状态码。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>After response header was sent to the client, this property indicates the status code which was sent out.</p>
                    </div>
                </div>
                <h3>response.statusMessage<span><a class="mark" href="#http_response_statusmessage" id="http_response_statusmessage">#</a></span></h3>
                <p>当使用隐式头时(没有显式地调用 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 来修改头)，这个属性控制着在头被刷入时一并发送回客户端的状态信息。
                    如果任其为 <code>undefined</code> 那么将用标准的对应的状态码的消息。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>When using implicit headers (not calling <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> explicitly), this property controls the status message that will be sent to the client when
                            the headers get flushed. If this is left as <code>undefined</code> then the standard message for the status code will be used.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">response.statusMessage = &#39;Not found&#39;;
</code></pre>
                <p>当响应头被发送回客户端，这个属性标识已经被发送出去的状态信息。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>After response header was sent to the client, this property indicates the status message which was sent out.</p>
                    </div>
                </div>
                <h3>response.write(chunk[, encoding][, callback])<span><a class="mark" href="#http_response_write_chunk_encoding_callback" id="http_response_write_chunk_encoding_callback">#</a></span></h3>
                <p>如果这个方法被调用，且 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 没有被调用，
                    它将切换到隐式头模式并刷入隐式头。</p>
                <p>这个方法发送一个响应体的数据块。可能会被调用多次从而提供出一个体响应连续的部分。</p>
                <p><code>chunk</code> 可以是字符串或者buffer。如果 <code>chunk</code> 是一个字符串，第二个参数指定如何将这个字符串编码为一个字节流。默认的 <code>encoding</code> 是 <code>&#39;utf8&#39;</code>。</p>
                <p><strong>注意</strong>： 这是原始的 HTTP 报文，与那些可能被使用到的高级的多部分的报文编码无关。</p>
                <p>当第一次 <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> 被调用时，将会发送缓存的头信息和第一个报文给客户端。
                    第二次 <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> 被调用时， Node.js 假设你将发送数据流，然后分别地发
                    送。这意味着响应是缓存到第一次报文的数据块中。</p>
                <p>如果所有数据被成功刷新到内核缓冲区，则返回 <code>true</code>。如果全部或部分数据在用户内存里还处于队列中，则返回 <code>false</code>。当缓冲区再次被释放时，<code>&#39;drain&#39;</code> 事件会被触发。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>If this method is called and <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> has not been called, it will switch to implicit header mode and flush the implicit headers.</p>
                        <p>This sends a chunk of the response body. This method may be called multiple times to provide successive parts of the body.</p>
                        <p><code>chunk</code> can be a string or a buffer. If <code>chunk</code> is a string, the second parameter specifies how to encode it into a byte stream. By default the <code>encoding</code> is <code>&#39;utf8&#39;</code>. The last parameter
                            <code>callback</code> will be called when this chunk of data is flushed.</p>
                        <p><strong>Note</strong>: This is the raw HTTP body and has nothing to do with higher-level multi-part body encodings that may be used.</p>
                        <p>The first time <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> is called, it will send the buffered header information and the first body to the client. The second time
                            <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> is called, Node.js assumes you&#39;re going to be streaming data, and sends that separately. That is, the response is buffered up to the first
                            chunk of body.</p>
                        <p>Returns <code>true</code> if the entire data was flushed successfully to the kernel buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
                            <code>&#39;drain&#39;</code> will be emitted when the buffer is free again.</p>
                    </div>
                </div>
                <h3>response.writeContinue()<span><a class="mark" href="#http_response_writecontinue" id="http_response_writecontinue">#</a></span></h3>
                <p>发送一个 HTTP/1.1 100 Continue 消息至客户端，指明请求体该被发送了。可在 <code>Server</code> 上查看 <a href="#http_event_checkcontinue"><code>&#39;checkContinue&#39;</code></a> 事件。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sends a HTTP/1.1 100 Continue message to the client, indicating that the request body should be sent. See the <a href="#http_event_checkcontinue"><code>&#39;checkContinue&#39;</code></a> event on <code>Server</code>.</p>
                    </div>
                </div>
                <h3>response.writeHead(statusCode[, statusMessage][, headers])<span><a class="mark" href="#http_response_writehead_statuscode_statusmessage_headers" id="http_response_writehead_statuscode_statusmessage_headers">#</a></span></h3>
                <p>向请求回复响应头。状态码是一个三位数字的是的 HTTP 状态码，例如 <code>404</code>。最后一个参数 <code>headers</code> 是响应头。
                    可选择性提供一个人类可读的 <code>statusMessage</code> 作为第二个参数。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Sends a response header to the request. The status code is a 3-digit HTTP status code, like <code>404</code>. The last argument, <code>headers</code>, are the response headers. Optionally one can give a human-readable <code>statusMessage</code> as the second argument.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">var body = &#39;hello world&#39;;
response.writeHead(200, {
  &#39;Content-Length&#39;: body.length,
  &#39;Content-Type&#39;: &#39;text/plain&#39; });
</code></pre>
                <p>这个方法必须只在一个消息上被调用一次，且必须在调用 <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> 之前调用。</p>
                <p>如果你在调用这之前调用了 <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> 或 <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a>，
                    就会调用这个函数，并且隐式/可变的的头将会被计算出来，并为你调用这个方法。</p>
                <p>当用 <a href="#http_response_setheader_name_value"><code>response.setHeader()</code></a> 设置头时，她们会被合并到传给 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 的头里面去，
                        传给 <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> 优先级较高。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>This method must only be called once on a message and it must be called before <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> is called.</p>
                        <p>If you call <a href="#http_response_write_chunk_encoding_callback"><code>response.write()</code></a> or <a href="#http_response_end_data_encoding_callback"><code>response.end()</code></a> before calling this, the implicit/mutable headers
                            will be calculated and call this function for you.</p>
                        <p>When headers have been set with <a href="#http_response_setheader_name_value"><code>response.setHeader()</code></a>, they will be merged with any headers passed to <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a>,
                            with the headers passed to
                            <a href="#http_response_writehead_statuscode_statusmessage_headers"><code>response.writeHead()</code></a> given precedence.</p>
                    </div>
                </div>
                <pre><code class="lang-js">// returns content-type = text/plain
const server = http.createServer((req,res) =&gt; {
  res.setHeader(&#39;Content-Type&#39;, &#39;text/html&#39;);
  res.setHeader(&#39;X-Foo&#39;, &#39;bar&#39;);
  res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;});
  res.end(&#39;ok&#39;);
});
</code></pre>
                <p>注意：Content-Length 是按字节而不是字符计算的。之前的例子奏效的原因是字符串 <code>&#39;hello world&#39;</code> 只包含了单字节的字符。
                    如果 body 包含了多字节编码的字符，就应当使用 <code>Buffer.byteLength()</code> 来确定在指定字符编码的情况下的字节数。并且 Node.js 不检查
                    Content-Lenth 属性和已传输的 body 长度是否吻合。</p>
                <p>试图设置含有非法字符的头字段名或值，会抛出一个 <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a> 错误。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Note that Content-Length is given in bytes not characters. The above example works because the string <code>&#39;hello world&#39;</code> contains only single byte characters. If the body contains higher coded characters then <code>Buffer.byteLength()</code>                    should be used to determine the number of bytes in a given encoding. And Node.js does not check whether Content-Length and the length of the body which has been transmitted are equal or not.</p>
                        <p>Attempting to set a header field name or value that contains invalid characters will result in a <a href="errors.html#errors_class_typeerror"><code>TypeError</code></a> being thrown.</p>
                    </div>
                </div>
                <h2>Class: http.IncomingMessage<span><a class="mark" href="#http_class_http_incomingmessage" id="http_class_http_incomingmessage">#</a></span></h2>
                <p>一个 <code>IncomingMessage</code> 对象是由 <a href="#http_class_http_server"><code>http.Server</code></a> 或 <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> 创建的，
                    并作为第一参数传递给 <code>&#39;request&#39;</code> 和 <code>&#39;response&#39;</code> 事件。它可被用来访问响应的状态、头和数据。</p>
                <p>它实现了 <a href="stream.html#stream_class_stream_readable">Readable Stream</a> 接口以及以下额外的事件、方法和属性。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>An <code>IncomingMessage</code> object is created by <a href="#http_class_http_server"><code>http.Server</code></a> or
                            <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> and passed as the first argument to the <code>&#39;request&#39;</code> and <code>&#39;response&#39;</code> event respectively. It may be used to access response
                            status, headers and data.</p>
                        <p>It implements the <a href="stream.html#stream_class_stream_readable">Readable Stream</a> interface, as well as the following additional events, methods, and properties.</p>
                    </div>
                </div>
                <h3>Event: &#39;close&#39;<span><a class="mark" href="#http_event_close_2" id="http_event_close_2">#</a></span></h3>
                <p><code>function () { }</code></p>
                <p>标识底层连接被关闭。跟 <code>&#39;end&#39;</code> 一样，这个事件对于每个应答只会触发一次。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Indicates that the underlying connection was closed. Just like <code>&#39;end&#39;</code>, this event occurs only once per response.</p>
                    </div>
                </div>
                <h3>message.headers<span><a class="mark" href="#http_message_headers" id="http_message_headers">#</a></span></h3>
                <p>请求/响应头对象。</p>
                <p>头名和值的键-值对。头名称全小写。示例：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The request/response headers object.</p>
                        <p>Key-value pairs of header names and values. Header names are lower-cased. Example:</p>
                    </div>
                </div>
                <pre><code class="lang-js">// Prints something like:
//
// { &#39;user-agent&#39;: &#39;curl/7.22.0&#39;,
//   host: &#39;127.0.0.1:8000&#39;,
//   accept: &#39;*/*&#39; }
console.log(request.headers);
</code></pre>
                <p>根据头名的不同，有如下几种方式用于处理头内有多个重复副本的情况：</p>
                <ul>
                    <li><code>age</code>、<code>authorization</code>、<code>content-length</code>、<code>content-type</code>,
                        <code>etag</code>、<code>expires</code>、<code>from</code>、<code>host</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>,
                        <code>last-modified</code>、<code>location</code>、<code>max-forwards</code>、<code>proxy-authorization</code>、<code>referer</code>,
                        <code>retry-after</code> 或 <code>user-agent</code> 这些副本不存储。</li>
                    <li><code>set-cookie</code> 总是一个数组。副本会添加到数组里面。</li>
                    <li>其余的，用 &#39;, &#39; 分隔拼接在一起。</li>
                </ul>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Duplicates in raw headers are handled in the following ways, depending on the header name:</p>
                        <ul>
                            <li>Duplicates of <code>age</code>, <code>authorization</code>, <code>content-length</code>, <code>content-type</code>,
                                <code>etag</code>, <code>expires</code>, <code>from</code>, <code>host</code>, <code>if-modified-since</code>, <code>if-unmodified-since</code>,
                                <code>last-modified</code>, <code>location</code>, <code>max-forwards</code>, <code>proxy-authorization</code>, <code>referer</code>,
                                <code>retry-after</code>, or <code>user-agent</code> are discarded.</li>
                            <li><code>set-cookie</code> is always an array. Duplicates are added to the array.</li>
                            <li>For all other headers, the values are joined together with &#39;, &#39;.</li>
                        </ul>
                    </div>
                </div>
                <h3>message.httpVersion<span><a class="mark" href="#http_message_httpversion" id="http_message_httpversion">#</a></span></h3>
                <p>客户端向服务器发出请求时，客户端发送的 HTTP 版本；或是服务器应答客户端时，服务器的 HTTP 版本。通常是 <code>&#39;1.1&#39;</code> 或 <code>&#39;1.0&#39;</code>。</p>
                <p>另外，<code>message.httpVersionMajor</code> 是第一个整数，<code>message.httpVersionMinor</code> 是第二个整数。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>In case of server request, the HTTP version sent by the client. In the case of client response, the HTTP version of the connected-to server. Probably either <code>&#39;1.1&#39;</code> or <code>&#39;1.0&#39;</code>.</p>
                        <p>Also <code>message.httpVersionMajor</code> is the first integer and
                            <code>message.httpVersionMinor</code> is the second.</p>
                    </div>
                </div>
                <h3>message.method<span><a class="mark" href="#http_message_method" id="http_message_method">#</a></span></h3>
                <p><strong>仅对从 <a href="#http_class_http_server"><code>http.Server</code></a> 获得到的请求有效。</strong></p>
                <p>请求方法如是一个只读的字符串，比如： <code>&#39;GET&#39;</code>、<code>&#39;DELETE&#39;</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><strong>Only valid for request obtained from <a href="#http_class_http_server"><code>http.Server</code></a>.</strong></p>
                        <p>The request method as a string. Read only. Example:
                            <code>&#39;GET&#39;</code>, <code>&#39;DELETE&#39;</code>.</p>
                    </div>
                </div>
                <h3>message.rawHeaders<span><a class="mark" href="#http_message_rawheaders" id="http_message_rawheaders">#</a></span></h3>
                <p>接收到的原始请求/响应头字段列表。</p>
                <p>注意键和值在同一个列表中，她<em>并非</em>一个元组列表。所以，偶数偏移量为键，奇数偏移量为对应的值。</p>
                <p>头名称没有转换为小写，也没有合并重复的头。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The raw request/response headers list exactly as they were received.</p>
                        <p>Note that the keys and values are in the same list. It is <em>not</em> a list of tuples. So, the even-numbered offsets are key values, and the odd-numbered offsets are the associated values.</p>
                        <p>Header names are not lowercased, and duplicates are not merged.</p>
                    </div>
                </div>
                <pre><code class="lang-js">// Prints something like:
//
// [ &#39;user-agent&#39;,
//   &#39;this is invalid because there can be only one&#39;,
//   &#39;User-Agent&#39;,
//   &#39;curl/7.22.0&#39;,
//   &#39;Host&#39;,
//   &#39;127.0.0.1:8000&#39;,
//   &#39;ACCEPT&#39;,
//   &#39;*/*&#39; ]
console.log(request.rawHeaders);
</code></pre>
                <h3>message.rawTrailers<span><a class="mark" href="#http_message_rawtrailers" id="http_message_rawtrailers">#</a></span></h3>
                <p>接收到的原始的请求/响应尾部键和值，只填充在 <code>&#39;end&#39;</code> 事件上。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The raw request/response trailer keys and values exactly as they were received. Only populated at the <code>&#39;end&#39;</code> event.</p>
                    </div>
                </div>
                <h3>message.setTimeout(msecs, callback)<span><a class="mark" href="#http_message_settimeout_msecs_callback" id="http_message_settimeout_msecs_callback">#</a></span></h3>
                <div class="signature">
                    <ul>
                        <li><code>msecs</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures#Number_type" class="type">&lt;Number&gt;</a></li>
                        <li><code>callback</code> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function" class="type">&lt;Function&gt;</a></li>
                    </ul>
                </div>
                <p>调用 <code>message.connection.setTimeout(msecs, callback)</code>。</p>
                <p>返回 <code>message</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Calls <code>message.connection.setTimeout(msecs, callback)</code>.</p>
                        <p>Returns <code>message</code>.</p>
                    </div>
                </div>
                <h3>message.statusCode<span><a class="mark" href="#http_message_statuscode" id="http_message_statuscode">#</a></span></h3>
                <p><strong>仅对从 <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> 获得的响应有效. .</strong></p>
                <p>三位数字的 HTTP 响应状态码，例如： <code>404</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><strong>Only valid for response obtained from <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a>.</strong></p>
                        <p>The 3-digit HTTP response status code. E.G. <code>404</code>.</p>
                    </div>
                </div>
                <h3>message.statusMessage<span><a class="mark" href="#http_message_statusmessage" id="http_message_statusmessage">#</a></span></h3>
                <p><strong>只在从 <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> 获取到的响应有效。</strong></p>
                <p>HTTP 响应状态信息(原因描述)，例如： <code>OK</code> 或 <code>Internal Server Error</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><strong>Only valid for response obtained from <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a>.</strong></p>
                        <p>The HTTP response status message (reason phrase). E.G. <code>OK</code> or <code>Internal Server Error</code>.</p>
                    </div>
                </div>
                <h3>message.socket<span><a class="mark" href="#http_message_socket" id="http_message_socket">#</a></span></h3>
                <p>与此连接(connection)相关的 <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> 对象。</p>
                <p>通过 https 的支持，使用 <a href="tls.html#tls_tlssocket_getpeercertificate_detailed"><code>request.socket.getPeerCertificate()</code></a> 方法来得到客户端的身份信息</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>The <a href="net.html#net_class_net_socket"><code>net.Socket</code></a> object associated with the connection.</p>
                        <p>With HTTPS support, use <a href="tls.html#tls_tlssocket_getpeercertificate_detailed"><code>request.socket.getPeerCertificate()</code></a> to obtain the client&#39;s authentication details.</p>
                    </div>
                </div>
                <h3>message.trailers<span><a class="mark" href="#http_message_trailers" id="http_message_trailers">#</a></span></h3>
                <p>请求/响应尾部对象，只填充在 <code>&#39;end&#39;</code> 事件上(The request/response trailers object. Only populated at the <code>&#39;end&#39;</code> event)。</p>
                <h3>message.url<span><a class="mark" href="#http_message_url" id="http_message_url">#</a></span></h3>
                <p><strong>仅对从 <a href="#http_class_http_server"><code>http.Server</code></a> 获得到的请求有效。</strong></p>
                <p>请求的 URL 字符串。它仅包含实际 HTTP 请求中所提供的 URL。如果请求如下:</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p><strong>Only valid for request obtained from <a href="#http_class_http_server"><code>http.Server</code></a>.</strong></p>
                        <p>Request URL string. This contains only the URL that is present in the actual HTTP request. If the request is:</p>
                    </div>
                </div>
                <pre><code>GET /status?name=ryan HTTP/1.1\r\n
Accept: text/plain\r\n
\r\n
</code></pre>
                <p>那么 <code>request.url</code> 会是这样(Then <code>request.url</code> will be)：</p>
                <pre><code>&#39;/status?name=ryan&#39;
</code></pre>
                <p>如果你想要将 URL 分解出来，你可以用 <code>require(&#39;url&#39;).parse(request.url)</code>。例如：</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>If you would like to parse the URL into its parts, you can use <code>require(&#39;url&#39;).parse(request.url)</code>. Example:</p>
                    </div>
                </div>
                <pre><code>$ node
&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;)
{
  href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: &#39;name=ryan&#39;,
  pathname: &#39;/status&#39;
}
</code></pre>
                <p>如果你想要提取出从请求字符串中的参数,你可以用 <code>require(&#39;querystring&#39;).parse</code> 函数，或者将 <code>true</code> 作为
                    第二个参数传递给 <code>require(&#39;url&#39;).parse</code>。例如:</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>If you would like to extract the params from the query string, you can use the <code>require(&#39;querystring&#39;).parse</code> function, or pass
                            <code>true</code> as the second argument to <code>require(&#39;url&#39;).parse</code>. Example:</p>
                    </div>
                </div>
                <pre><code>$ node
&gt; require(&#39;url&#39;).parse(&#39;/status?name=ryan&#39;, true)
{
  href: &#39;/status?name=ryan&#39;,
  search: &#39;?name=ryan&#39;,
  query: {name: &#39;ryan&#39;},
  pathname: &#39;/status&#39;
}
</code></pre>
                <h2>http.METHODS<span><a class="mark" href="#http_http_methods" id="http_http_methods">#</a></span></h2>
                <div class="signature">
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" class="type">&lt;Array&gt;</a></li>
                    </ul>
                </div>
                <p>一个解析器(parser)所支持的 HTTP 方法列表。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>A list of the HTTP methods that are supported by the parser.</p>
                    </div>
                </div>
                <h2>http.STATUS_CODES<span><a class="mark" href="#http_http_status_codes" id="http_http_status_codes">#</a></span></h2>
                <div class="signature">
                    <ul>
                        <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" class="type">&lt;Object&gt;</a></li>
                    </ul>
                </div>
                <p>全部标准 HTTP 响应状态码的集合和简短描述。例如：<code>http.STATUS_CODES[404] === &#39;Not Found&#39;</code>。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>A collection of all the standard HTTP response status codes, and the short description of each. For example, <code>http.STATUS_CODES[404] === &#39;Not Found&#39;</code>.</p>
                    </div>
                </div>
                <h2>http.createClient([port][, host])<span><a class="mark" href="#http_http_createclient_port_host" id="http_http_createclient_port_host">#</a></span></h2>
                <pre class="api_stability api_stability_0">稳定性: 0 - 已废弃: 用 <a href="#http_http_request_options_callback"><code>http.request()</code></a> 代替。</pre>
                <p>构造一个新的 HTTP 客户端。<code>port</code> 和 <code>host</code> 表示所连接的服务器。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Constructs a new HTTP client. <code>port</code> and <code>host</code> refer to the server to be connected to.</p>
                    </div>
                </div>
                <h2>http.createServer([requestListener])<span><a class="mark" href="#http_http_createserver_requestlistener" id="http_http_createserver_requestlistener">#</a></span></h2>
                <p>返回一个新的 <a href="#http_class_http_server"><code>http.Server</code></a> 服务器对象。</p>
                <p>参数 <code>requestListener</code> 是一个函数，它将会自动加入到 <code>&#39;request&#39;</code> 事件。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Returns a new instance of <a href="#http_class_http_server"><code>http.Server</code></a>.</p>
                        <p>The <code>requestListener</code> is a function which is automatically added to the <code>&#39;request&#39;</code> event.</p>
                    </div>
                </div>
                <h2>http.get(options[, callback])<span><a class="mark" href="#http_http_get_options_callback" id="http_http_get_options_callback">#</a></span></h2>
                <p>因为大部分的请求是没有报文体的 GET 请求，所以 Node.js 提供了这个快捷的方法。该方法与 <a href="#http_http_request_options_callback"><code>http.request()</code></a> 的
                    唯一区别是它设置的是 GET 方法并自动调用req.end()。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Since most requests are GET requests without bodies, Node.js provides this convenience method. The only difference between this method and <a href="#http_http_request_options_callback"><code>http.request()</code></a> is that it sets the
                            method to GET and calls <code>req.end()</code> automatically.Example:</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">http.get(&#39;http://www.google.com/index.html&#39;, (res) =&gt; {
  console.log(`Got response: ${res.statusCode}`);
  // consume response body
  res.resume();
}).on(&#39;error&#39;, (e) =&gt; {
  console.log(`Got error: ${e.message}`);
});
</code></pre>
                <h2>http.globalAgent<span><a class="mark" href="#http_http_globalagent" id="http_http_globalagent">#</a></span></h2>
                <p>超全局的代理实例，是所有 http 客户端的默认的代理。</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Global instance of Agent which is used as the default for all http client requests.</p>
                    </div>
                </div>
                <h2>http.request(options[, callback])<span><a class="mark" href="#http_http_request_options_callback" id="http_http_request_options_callback">#</a></span></h2>
                <p>Node.js 在每个服务器上维护着几个用于发起 HTTP 请求的连接。这个函数允许透明地发起请求。</p>
                <p><code>options</code> 可以是一个对象或一个字符串。如果 <code>options</code> 是一个字符串, 它将自动使用 <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost"><code>url.parse()</code></a> 做解析。</p>
                <p>Options:</p>
                <ul>
                    <li><code>protocol</code>: Protocol to use. Defaults to <code>&#39;http:&#39;</code>.</li>
                    <li><code>host</code>: A domain name or IP address of the server to issue the request to. Defaults to <code>&#39;localhost&#39;</code>.</li>
                    <li><code>hostname</code>: Alias for <code>host</code>. To support <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost"><code>url.parse()</code></a> <code>hostname</code> is preferred over <code>host</code>.</li>
                    <li><code>family</code>: IP address family to use when resolving <code>host</code> and <code>hostname</code>. Valid values are <code>4</code> or <code>6</code>. When unspecified, both IP v4 and v6 will be used.
                    </li>
                    <li><code>port</code>: Port of remote server. Defaults to 80.</li>
                    <li><code>localAddress</code>: Local interface to bind for network connections.</li>
                    <li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath).</li>
                    <li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;</code>.</li>
                    <li><code>path</code>: Request path. Defaults to <code>&#39;/&#39;</code>. Should include query string if any. E.G. <code>&#39;/index.html?page=12&#39;</code>. An exception is thrown when the request path contains illegal characters. Currently,
                        only spaces are rejected but that may change in the future.</li>
                    <li><code>headers</code>: An object containing request headers.</li>
                    <li><code>auth</code>: Basic authentication i.e. <code>&#39;user:password&#39;</code> to compute an Authorization header.</li>
                    <li><code>agent</code>: Controls <a href="#http_class_http_agent"><code>Agent</code></a> behavior. When an Agent is used request will default to <code>Connection: keep-alive</code>. Possible values:
                        <ul>
                            <li><code>undefined</code> (default): use <a href="#http_http_globalagent"><code>http.globalAgent</code></a> for this host and port.</li>
                            <li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
                            <li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
                                <code>Connection: close</code>.</li>
                        </ul>
                    </li>
                    <li><code>createConnection</code>: A function that produces a socket/stream to use for the request when the <code>agent</code> option is not used. This can be used to avoid creating a custom Agent class just to override the default <code>createConnection</code>                        function. See <a href="#http_agent_createconnection_options_callback"><code>agent.createConnection()</code></a> for more details.</li>
                </ul>
                <p>The optional <code>callback</code> parameter will be added as a one time listener for the <code>&#39;response&#39;</code> event.</p>
                <p><code>http.request()</code> returns an instance of the <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> class. The <code>ClientRequest</code> instance is a writable stream. If one needs to upload a file with
                    a POST request, then write to the <code>ClientRequest</code> object.</p>
                <div class="hhy-original-div">
                    <button class="hhy-toggle-btn">原文</button>
                    <div class="hhy-original-text">
                        <p>Node.js maintains several connections per server to make HTTP requests. This function allows one to transparently issue requests.</p>
                        <p><code>options</code> can be an object or a string. If <code>options</code> is a string, it is automatically parsed with <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost"><code>url.parse()</code></a>.</p>
                        <p>Options:</p>
                        <ul>
                            <li><code>protocol</code>: Protocol to use. Defaults to <code>&#39;http:&#39;</code>.</li>
                            <li><code>host</code>: A domain name or IP address of the server to issue the request to. Defaults to <code>&#39;localhost&#39;</code>.</li>
                            <li><code>hostname</code>: Alias for <code>host</code>. To support <a href="url.html#url_url_parse_urlstr_parsequerystring_slashesdenotehost"><code>url.parse()</code></a> <code>hostname</code> is preferred over <code>host</code>.</li>
                            <li><code>family</code>: IP address family to use when resolving <code>host</code> and <code>hostname</code>. Valid values are <code>4</code> or <code>6</code>. When unspecified, both IP v4 and v6 will be used.
                            </li>
                            <li><code>port</code>: Port of remote server. Defaults to 80.</li>
                            <li><code>localAddress</code>: Local interface to bind for network connections.</li>
                            <li><code>socketPath</code>: Unix Domain Socket (use one of host:port or socketPath).</li>
                            <li><code>method</code>: A string specifying the HTTP request method. Defaults to <code>&#39;GET&#39;</code>.</li>
                            <li><code>path</code>: Request path. Defaults to <code>&#39;/&#39;</code>. Should include query string if any. E.G. <code>&#39;/index.html?page=12&#39;</code>. An exception is thrown when the request path contains illegal characters. Currently,
                                only spaces are rejected but that may change in the future.</li>
                            <li><code>headers</code>: An object containing request headers.</li>
                            <li><code>auth</code>: Basic authentication i.e. <code>&#39;user:password&#39;</code> to compute an Authorization header.</li>
                            <li><code>agent</code>: Controls <a href="#http_class_http_agent"><code>Agent</code></a> behavior. When an Agent is used request will default to <code>Connection: keep-alive</code>. Possible values:
                                <ul>
                                    <li><code>undefined</code> (default): use <a href="#http_http_globalagent"><code>http.globalAgent</code></a> for this host and port.</li>
                                    <li><code>Agent</code> object: explicitly use the passed in <code>Agent</code>.</li>
                                    <li><code>false</code>: opts out of connection pooling with an Agent, defaults request to
                                        <code>Connection: close</code>.</li>
                                </ul>
                            </li>
                            <li><code>createConnection</code>: A function that produces a socket/stream to use for the request when the <code>agent</code> option is not used. This can be used to avoid creating a custom Agent class just to override the default <code>createConnection</code>                        function. See <a href="#http_agent_createconnection_options_callback"><code>agent.createConnection()</code></a> for more details.</li>
                        </ul>
                        <p>The optional <code>callback</code> parameter will be added as a one time listener for the <code>&#39;response&#39;</code> event.</p>
                        <p><code>http.request()</code> returns an instance of the <a href="#http_class_http_clientrequest"><code>http.ClientRequest</code></a> class. The <code>ClientRequest</code> instance is a writable stream. If one needs to upload a file with
                            a POST request, then write to the <code>ClientRequest</code> object.</p>
                    </div>
                </div>
                <p>示例(Example)：</p>
                <pre><code class="lang-js">var postData = querystring.stringify({
  &#39;msg&#39; : &#39;Hello World!&#39;
});

var options = {
  hostname: &#39;www.google.com&#39;,
  port: 80,
  path: &#39;/upload&#39;,
  method: &#39;POST&#39;,
  headers: {
    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
    &#39;Content-Length&#39;: postData.length
  }
};

var req = http.request(options, (res) =&gt; {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding(&#39;utf8&#39;);
  res.on(&#39;data&#39;, (chunk) =&gt; {
    console.log(`BODY: ${chunk}`);
  });
  res.on(&#39;end&#39;, () =&gt; {
    console.log(&#39;No more data in response.&#39;)
  })
});

req.on(&#39;error&#39;, (e) =&gt; {
  console.log(`problem with request: ${e.message}`);
});

// write data to request body
req.write(postData);
req.end();
</code></pre>
                <p>Note that in the example <code>req.end()</code> was called. With <code>http.request()</code> one must always call <code>req.end()</code> to signify that you&#39;re done with the request - even if there is no data being written to the request
                    body.
                </p>
                <p>If any error is encountered during the request (be that with DNS resolution, TCP level errors, or actual HTTP parse errors) an <code>&#39;error&#39;</code> event is emitted on the returned request object. As with all <code>&#39;error&#39;</code>                    events, if no listeners are registered the error will be thrown.</p>
                <p>There are a few special headers that should be noted.</p>
                <ul>
                    <li>
                        <p>Sending a &#39;Connection: keep-alive&#39; will notify Node.js that the connection to the server should be persisted until the next request.</p>
                    </li>
                    <li>
                        <p>Sending a &#39;Content-length&#39; header will disable the default chunked encoding.</p>
                    </li>
                    <li>
                        <p>Sending an &#39;Expect&#39; header will immediately send the request headers. Usually, when sending &#39;Expect: 100-continue&#39;, you should both set a timeout and listen for the <code>&#39;continue&#39;</code> event. See RFC2616
                            Section 8.2.3 for more information.
                        </p>
                    </li>
                    <li>
                        <p>Sending an Authorization header will override using the <code>auth</code> option to compute basic authentication.</p>
                    </li>
                </ul>

            </div>
        </div>
    </div>
    <script src="assets/sh_main.js"></script>
    <script src="assets/sh_javascript.min.js"></script>
    <script>
        highlight(undefined, undefined, 'pre');
    </script>
</body>

</html>
